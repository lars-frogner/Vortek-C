#
# Usage:
# make <argument 1> <argument 2> ...
#
# Arguments:
# <none>:  Compiles with no compiler flags.
# debug:   Compiles with flags useful for debugging.
# fast:    Compiles with flags for high performance.
# clean:   Deletes auxiliary files.
#
# To compile with additional flags, add the argument
# EXTRA_FLAGS="<flags>"

# Compiler
CC = cc

# Directories
ROOT_DIR := .
SRC_DIR := ${ROOT_DIR}/src
BINARY_DIR := ${ROOT_DIR}/binary
OBJ_DIR := ${ROOT_DIR}/obj
INCLUDE_DIR := ${ROOT_DIR}/include
EXTERNAL_DIR := ${ROOT_DIR}/external
DEP_DIR := ${ROOT_DIR}/.d

# Executable binary
EXECUTABLE_BINARY := ${ROOT_DIR}/vortek.x
EXECUTABLE_SOURCE := ${BINARY_DIR}/executable.c
EXECUTABLE_OBJECT := ${OBJ_DIR}/executable.o

# Python module binary
PYTHON_MODULE_BINARY := ${ROOT_DIR}/vortek.so
PYTHON_MODULE_SOURCE := ${BINARY_DIR}/python_module.c
PYTHON_MODULE_OBJECT := ${OBJ_DIR}/python_module.o

# Make sure required folders exist
$(shell mkdir -p ${OBJ_DIR} > /dev/null)
$(shell mkdir -p ${DEP_DIR} > /dev/null)

# Find all source files and create list of corresponding object files
SOURCE_FILES := $(shell find ${SRC_DIR} -name "*.c")
OBJECT_FILES := $(patsubst ${SRC_DIR}/%,${OBJ_DIR}/%,$(patsubst %.c,%.o,$(SOURCE_FILES)))

# Makes the compiler generate temporary dependency files (.Td) for each object file
DEP_FLAGS = -MT $@ -MMD -MP -MF ${DEP_DIR}/$*.Td

HEADER_PATH_FLAGS := -I${INCLUDE_DIR} -I${EXTERNAL_DIR}/include

LIBRARY_PATH_FLAGS := -L${EXTERNAL_DIR}/lib
LIBRARY_LINKING_FLAGS := -lglfw

COMPILATION_FLAGS := -march=native -mtune=native
LINKING_FLAGS := -march=native -mtune=native

DEBUGGING_COMPILATION_FLAGS := -g -O0 -W -Wall -fno-common -Wcast-align -Wredundant-decls -Wbad-function-cast -Wwrite-strings -Wstrict-prototypes -Wmissing-prototypes -Wextra -Wconversion -pedantic -Wno-unused-parameter -fsanitize=address -fno-omit-frame-pointer -fno-optimize-sibling-calls
DEBUGGING_LINKING_FLAGS := -fsanitize=address

PERFORMANCE_COMPILATION_FLAGS := -O3 -ffast-math
PERFORMANCE_LINKING_FLAGS := ${PERFORMANCE_COMPILATION_FLAGS}

# Add operating system specific flags
ifeq (${OS},Windows_NT)
    $(error This makefile does not support Windows)
else
	UNAME_S := $(shell uname -s)
	ifeq (${UNAME_S},Linux)
		LIBRARY_LINKING_FLAGS += -lm -lGL -lGLU
	endif
	ifeq (${UNAME_S},Darwin)
		COMPILATION_FLAGS     += -Wno-deprecated-declarations
		LINKING_FLAGS         += -framework OpenGL
	endif
endif

ifdef MAKE_VORTEK_EXECUTABLE
	BINARY       := ${EXECUTABLE_BINARY}
	SOURCE_FILES += ${EXECUTABLE_SOURCE}
	OBJECT_FILES += ${EXECUTABLE_OBJECT}
else
	PYTHON_COMMAND := python
	PYTHON_STATUS := $(shell python --version > /dev/null 2>&1 ; echo $$?)
	ifneq (${PYTHON_STATUS},0)
        $(error No valid Python interpreter found)
	endif
	PYTHON_VERSION_NOT_3 := $(shell python -c "import sys; print(\"%i\" % (sys.hexversion < 0x03000000))")
	ifneq (${PYTHON_VERSION_NOT_3},0)
		PYTHON_3_STATUS := $(shell python3 --version > /dev/null 2>&1 ; echo $$?)
		ifneq (${PYTHON_3_STATUS},0)
            $(error No valid Python 3.x interpreter found)
		endif
		PYTHON_COMMAND := python3
	endif
	BINARY            := ${PYTHON_MODULE_BINARY}
	SOURCE_FILES      += ${PYTHON_MODULE_SOURCE}
	OBJECT_FILES      += ${PYTHON_MODULE_OBJECT}
	HEADER_PATH_FLAGS += -I$(shell ${PYTHON_COMMAND} -c "import distutils.sysconfig; print(distutils.sysconfig.get_python_inc())")
	HEADER_PATH_FLAGS += -I$(shell ${PYTHON_COMMAND} -c "import numpy; print(numpy.get_include())")/numpy
	COMPILATION_FLAGS += -fpic
	LINKING_FLAGS     += -shared -undefined dynamic_lookup
endif

# Command for compiling sources
COMPILE = ${CC} ${DEP_FLAGS} ${EXTRA_FLAGS} ${COMPILATION_FLAGS} ${HEADER_PATH_FLAGS}

# Command for linking objects
LINK = ${CC} ${EXTRA_FLAGS} ${LINKING_FLAGS} ${OBJECT_FILES} ${LIBRARY_PATH_FLAGS} ${LIBRARY_LINKING_FLAGS}

# Command for renaming temporary dependency files (.Td) generated by compiler
# to real dependency files (.d) and also touching the object file to make sure
# it is not reported as older than the corresponding dependency file
POSTCOMPILE = @mv -f ${DEP_DIR}/$*.Td ${DEP_DIR}/$*.d && touch $@

# Make sure certain rules are not activated by the presence of files
.PHONY: all debug fast clean superclean set_debug_flags set_fast_flags

# Define default target group
all: ${BINARY}

# Define optional target groups
debug: set_debug_flags ${BINARY}
fast: set_fast_flags ${BINARY}

# Action for removing all object files
clean:
	rm -f ${OBJECT_FILES} ${EXECUTABLE_OBJECT} ${PYTHON_MODULE_OBJECT}

# Action for removing all non-source files
superclean:
	rm -rf ${EXECUTABLE_BINARY} ${PYTHON_MODULE_BINARY} ${DEP_DIR} ${OBJ_DIR} ${EXTERNAL_DIR}

# Defines appropriate compiler flags for debugging
set_debug_flags:
	$(eval COMPILATION_FLAGS += ${DEBUGGING_COMPILATION_FLAGS})
	$(eval LINKING_FLAGS += ${DEBUGGING_LINKING_FLAGS})

# Defines appropriate compiler flags for high performance
set_fast_flags:
	$(eval COMPILATION_FLAGS += ${PERFORMANCE_COMPILATION_FLAGS})
	$(eval LINKING_FLAGS += ${PERFORMANCE_LINKING_FLAGS})

# Rule for linking object files
${BINARY}: ${EXTERNAL_DIR} ${OBJECT_FILES}
	${LINK} -o $@

# Rule for installing external dependencies
${EXTERNAL_DIR}:
	chmod +x install_externals.sh
	./install_externals.sh

# Rule for compiling sources
${OBJ_DIR}/%.o : ${SRC_DIR}/%.c ${DEP_DIR}/%.d
	${COMPILE} -o $@ -c $<
	${POSTCOMPILE}

# Rule for compiling binary source
${OBJ_DIR}/%.o : ${BINARY_DIR}/%.c ${DEP_DIR}/%.d
	${COMPILE} -o $@ -c $<
	${POSTCOMPILE}

# Empty rule for dependency files
${DEP_DIR}/%.d: ;

# Prevent dependency files from being deleted
.PRECIOUS: ${DEP_DIR}/%.d

# Include rules from all dependency files
include $(wildcard $(patsubst %,${DEP_DIR}/%.d,$(basename ${SOURCE_FILES})))
